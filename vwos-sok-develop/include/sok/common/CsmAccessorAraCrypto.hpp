/* Copyright (c) 2023 Volkswagen Group */

#ifndef CSM_ACCESSOR_ARA_CRYPTO_HPP
#define CSM_ACCESSOR_ARA_CRYPTO_HPP

#include "ICsmAccessor.hpp"
#include <ara/crypto/cryp/entry_point.h>
#include <ara/crypto/keys/key_storage_provider.h>
#include <unordered_map>

using ara::crypto::keys::KeyStorageProvider;
using ara::crypto::keys::SlotNumber;
namespace sok {
namespace common {

class CsmAccessorAraCrypto : public ICsmAccessor {
public:
    static constexpr char const* kAes128CmacString{"CMAC/AES-128"};

    CsmAccessorAraCrypto();

    /**
     * @brief convert MacAlgorithm enum to string
     * 
     * @param MacAlgorithm enum to convert
     * @return string view adapted to the enum
     */
    std::string EnumToStringMacAlgorithm(MacAlgorithm const eMacAlgorithm) const;

    /**
     * @brief Creates MAC
     * 
     * @param keyId symmetric key identifier to create the MAC with
     * @param data data to calculate the MAC over
     * @param alg algorithm of the MAC
     * @return CsmResult<std::vector<uint8_t>> Result object containing the generated MAC on success, error code otherwise
     */
    CsmResult<std::vector<uint8_t>> MacCreate(uint16_t keyId, std::vector<uint8_t> const& data, MacAlgorithm alg) const override;

    /**
     * @brief Verifies MAC, compares the mac parameter and the created one by the key, data, and alg according to the shortest of them
     * 
     * @param keyId symmetric key identifier to verify the MAC with
     * @param data the data to verify
     * @param mac the authenticator
     * @param alg algorithm of the MAC
     * @return CsmErrorCode kSuccess upon success, error code otherwise
     */
    CsmErrorCode MacVerify(uint16_t keyId, std::vector<uint8_t> const& data, std::vector<uint8_t> const& mac, MacAlgorithm alg) const override;

    /**
     * @brief Checks if the provided key identifier exists
     * 
     * @param keyId key identifier
     * @return CsmErrorCode kSuccess if key exists, error code otherwise
     */
    CsmErrorCode IsKeyExists(uint16_t keyId) const override;

    /**
     * @brief Generates random vector of bytes at the provided size
     * 
     * @param size amount of bytes to generate
     * @return CsmResult<std::vector<uint8_t>> Result object containing the generated byte vector, error code otherwise 
     */
    CsmResult<std::vector<uint8_t>> GenerateRandomBytes(uint8_t size) const override;

private:
    /**
     * @brief search for keyId in the local cache, if the keyId doesn't exist in the cache, the function add to the cache and returns the Uuid with out parameter
     * 
     * @param[in] keyId The key that the function looks for in the cache
     * @param[out] slotOut the slot that belongs to the requested keyId
     * @return boolean result, True is returned on success, False otherwise
     */
    bool GetKeyUuid(std::string const& keyId,ara::crypto::Uuid& slotOut) const;

    std::shared_ptr<ara::crypto::cryp::CryptoProvider> mCryptoProvider;
    std::shared_ptr<KeyStorageProvider> mKeyStorageProvider;
    
    /*local cache that map between string keyId to ara::crypto::Uuid object */
    mutable std::unordered_map<std::string, ara::crypto::Uuid> mKeysMap;
};    

} // namespace common
} // namespace sok

#endif // CSM_ACCESSOR_ARA_CRYPTO_HPP